function q8_part_b()

    clc;

    paths = load('paths.txt');      
    assert(mod(size(paths,1),2)==0, 'paths must have alternating x/y rows.');

    fire_center = [5, 5];
    fire_radius = 1.5;

    %start_point = [0.8, 1.8];
    %start_point = [2.2, 1.0];
    start_point = [2.7, 1.4];

    [up_x, up_y, down_x, down_y] = split_paths_up_down(paths, fire_center);
    
    % ---------- Pick 3 paths on the side whose starts better surround the start ----------
    [path_set_x, path_set_y] = pick_path_triple(up_x, up_y, down_x, down_y, start_point);

    % ---------- Compute barycentric weights for the start point ----------
    p1 = [path_set_x(1,1), path_set_y(1,1)];
    p2 = [path_set_x(2,1), path_set_y(2,1)];
    p3 = [path_set_x(3,1), path_set_y(3,1)];
    alpha = get_alpha(start_point, p1, p2, p3);

    % ---------- Blend the 3 paths to get the discrete new path ----------
    [new_path_x, new_path_y] = blend_paths(alpha, path_set_x, path_set_y);

    % ---------- Continuous-time interpolation over [0,1] ----------
    t = 0.01:0.01:0.99;
    interp_x = polyline_interp(new_path_x, t);
    interp_y = polyline_interp(new_path_y, t);

    % ---------- Obstacle (ring) check ----------
    d2 = (interp_x - fire_center(1)).^2 + (interp_y - fire_center(2)).^2;
    if any(d2 < fire_radius^2)
        warning('Interpolated path touches the ring of fire.');
    end

    % ---------- Plot ----------
    figure('Name','Q8(b) Interpolation','Color','w'); hold on; axis equal; grid on;
    title(sprintf('Interpolated Path   alpha = [%.3f, %.3f, %.3f]', alpha(1), alpha(2), alpha(3)));
    xlabel('x'); ylabel('y');

    % ring of fire
    th = linspace(0, 2*pi, 360);
    plot(fire_center(1) + fire_radius*cos(th), fire_center(2) + fire_radius*sin(th), 'm-', 'LineWidth', 1.25);

    % chosen three original paths
    cols = {'b--','g--','c--'};
    for i = 1:3
        plot(path_set_x(i,:), path_set_y(i,:), cols{i}, 'LineWidth', 1.0);
        plot(path_set_x(i,1), path_set_y(i,1), 'ko', 'MarkerSize', 5, 'MarkerFaceColor', 'k');
    end

    % interpolated path & start
    plot(interp_x, interp_y, 'r-', 'LineWidth', 2.0);
    plot(start_point(1), start_point(2), 'rx', 'MarkerSize', 10, 'LineWidth', 1.5);

    legend({'Ring of fire','Path 1','Path 2','Path 3','Interpolated'}, 'Location','bestoutside');
end


function [up_x, up_y, down_x, down_y] = split_paths_up_down(paths, center)

    [m, n] = size(paths);
    X = paths(1:2:m, :);
    Y = paths(2:2:m, :);

    mid = max(1, round(n/3)); 

    up_rows   = find(Y(:, mid) > center(2));
    down_rows = find(Y(:, mid) <= center(2));

    up_x   = X(up_rows, :);
    up_y   = Y(up_rows, :);
    down_x = X(down_rows, :);
    down_y = Y(down_rows, :);

    figure('Name','Up/Down Split','Color','w');
    subplot(1,2,1); hold on; axis equal; title('LEFT of ring'); grid on;
    for i = 1:size(up_x,1), plot(up_x(i,:), up_y(i,:)); end
    subplot(1,2,2); hold on; axis equal; title('RIGHT of ring'); grid on;
    for i = 1:size(down_x,1), plot(down_x(i,:), down_y(i,:)); end
end



function [path_set_x, path_set_y] = pick_path_triple(up_x, up_y, down_x, down_y, sp)

    side_center_left  = [mean(up_x(:,1)),  mean(up_y(:,1))];
    side_center_right = [mean(down_x(:,1)), mean(down_y(:,1))];

    if isempty(up_x)
        use_up = false;
    elseif isempty(down_x)
        use_up = true;
    else
        use_up = sum((sp - side_center_left).^2) <= sum((sp - side_center_right).^2);
    end

    if use_up
        px = up_x;  py = up_y;
    else
        px = down_x; py = down_y;
    end

    m = size(px, 1);
    if m < 3
        error('Not enough paths on the chosen side.');
    end

    candidates = [];
    for i = 1:m-2
        for j = i+1:m-1
            for k = j+1:m
                p1 = [px(i,1), py(i,1)];
                p2 = [px(j,1), py(j,1)];
                p3 = [px(k,1), py(k,1)];
                if triangle_area(p1,p2,p3) <= 1e-10, continue; end
                if point_in_triangle(sp, p1, p2, p3, 1e-12)
                    candidates = [candidates; i, j, k];
                end
            end
        end
    end 

    if isempty(candidates)
        error('No valid triangle contains the start point on the chosen side.');
    end

    nC = size(candidates, 1);
    dists = zeros(nC,1);
    for c = 1:nC
        i = candidates(c,1); j = candidates(c,2); k = candidates(c,3);
        p1 = [px(i,1), py(i,1)];
        p2 = [px(j,1), py(j,1)];
        p3 = [px(k,1), py(k,1)];
        center = (p1 + p2 + p3) / 3;
        dists(c) = sum((center - sp).^2);
    end
    [~, ind] = min(dists);

    path_set_x = [px(candidates(ind,1), :);
                  px(candidates(ind,2), :);
                  px(candidates(ind,3), :)];
    path_set_y = [py(candidates(ind,1), :);
                  py(candidates(ind,2), :);
                  py(candidates(ind,3), :)];
end


function [inside, alpha] = point_in_triangle(p, p1, p2, p3, tol)

    if nargin < 5, tol = 1e-12; end

    A = [p1(1) p2(1) p3(1);
         p1(2) p2(2) p3(2);
         1      1      1   ];
    b = [p(1); p(2); 1];

    detA = det(A);
    if abs(detA) < tol
        inside = false;
        alpha  = [NaN; NaN; NaN];
        return;
    end

    alpha = A \ b;

    nonneg = all(alpha >= -tol);             
    sum1   = abs(sum(alpha) - 1) <= 1e-9;    

    inside = nonneg && sum1;

    if inside
        alpha(alpha < 0 & alpha > -tol) = 0;
        s = sum(alpha);
        if abs(s - 1) > 1e-12
            alpha = alpha / s;
        end
    end
end

function alpha = get_alpha(sp, p1, p2, p3)

    M = [ (p1 - p3); (p2 - p3) ]';     
    b = (sp - p3)';                   
    if abs(det(M)) < 1e-14
        error('get_alpha: degenerate triangle.');
    end
    ab = M \ b;                     
    alpha = [ab(1); ab(2); 1 - ab(1) - ab(2)];
end


function [nx, ny] = blend_paths(alpha, path_set_x, path_set_y)
    nx = alpha' * path_set_x;          
    ny = alpha' * path_set_y;         
end


function y = polyline_interp(data, t)

    N = numel(data);
    s = (N - 1) * t;                   
    k = floor(s) + 1;                 
    k(k >= N) = N - 1;                
    frac = s - floor(s);              
    y = data(k) + (data(k+1) - data(k)) .* frac;
end


function A = triangle_area(p, q, r)
    A = 0.5 * abs( (q(1)-p(1))*(r(2)-p(2)) - (q(2)-p(2))*(r(1)-p(1)) );
end
